<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[first]]></title>
    <url>%2F2019%2F10%2F11%2Ffirst%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx和Xshell的使用]]></title>
    <url>%2F2019%2F10%2F09%2Fnginx%E5%92%8Cxshell%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[服务器部署静态资源（通过nginx反向代理）此处使用xshell与xftp组合连接本地与服务器，下载、安装xshell，xftp： https://www.netsarang.com/zh/xshell/ 这两个为付费软件，如果是自己使用可以下载破解版或选择家庭和学校用户的免费授权版。下载后进行一键式安装。 打开xshell创建连接： 填写好消息后点击连接。 打开Xftp 填写好消息后点击连接。 nginx下载 官方网址:http://nginx.org/en/download.html 启动Nginx start nginx 启动成功后，浏览器访问 localhost,即可看到Nginx 欢迎页 Nginx 常用命令 12345678910//在安装Nginx的目录下打开命令行运行nginx -h 查看帮助信息nginx -v 查看Nginx版本start nginx 启动nginx -s stop 停用Nginxnginx -s quit 优雅的停用Nginx（处理完正在进行中请求后停用）nginx -s reload 重新加载配置，并优雅的重启进程nginx -s reopen 重启日志文件 将项目部署到服务器 在xftp中进入如下目录： 在这个文件夹里新建一个文件夹，把它原有的这些文件放进去，注意不要选中那个..的文件夹，然后把之前本地打好的dist 包底下的内容放到这个html的文件夹里。 dist 文件夹不要了，html 下直接是你打好包的 index.html，以后打完包就直接替换这些文件就好了。]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度地图JavaScript API学习（二）]]></title>
    <url>%2F2019%2F09%2F29%2F%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[移动游标的圆形距离检索搜索某个店铺会有默认5公里的圆形检索区域，同时显示一个可移动的游标，点击“修改距离”标签即可输入距离查询。查询时移除之前的圆形覆盖物，获取游标位置，以该点为中心画新的圆形覆盖物。 效果如图： 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121 &lt;div id="top"&gt; &lt;div id="search" v-show="isShowSearh"&gt; &lt;div id="r-result"&gt; &lt;i class="back" @click="back"&gt;&lt;/i&gt; &lt;input type="text" id="suggestId" size="10" v-model="inputValue" placeholder="查找元祖店铺" @input="handleSearch" /&gt; &lt;i class="search-img"&gt;&lt;/i&gt; &lt;i class="close" @click="handleClear"&gt;&lt;/i&gt; &lt;/div&gt; &lt;ul id="list" v-show="cakeStoreList.length"&gt; &lt;li v-for="(item,index) in cakeStoreList" :key="index" @click="handleLocation(item)" &gt;&#123;&#123;item.dpname&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id="distanceInput" v-show="isShowDistance"&gt; &lt;input class="space" placeholder="默认：5（公里）" v-model="distanceValue" /&gt; &lt;div class="btn" @click="handleDistance"&gt;查询&lt;/div&gt;&lt;/div&gt;//搜索功能 handleSearch: _.debounce(function() &#123; let value = this.inputValue.trim(); if (!value) &#123; this.cakeStoreList = []; return; &#125; else &#123; fetchStore(value).then(res =&gt; &#123; if (res.data.rows.length &gt; 0) &#123; this.cakeStoreList = res.data.rows; &#125; &#125;); &#125; &#125;, 300), //点击列表项定位 handleLocation(item) &#123; this.map.removeOverlay(this.marker); this.inputValue = item.dpname; let city = ""; this.cakeStoreList = []; if (!item.jd || !item.wd) &#123; alert("对不起，这家店铺不存在！"); return; &#125; let point = new BMap.Point(item.jd, item.wd); this.geoc.getLocation(point, rs =&gt; &#123; let addComp = rs.addressComponents; city = addComp.city; &#125;); this.map.centerAndZoom(point, 13); this.marker = new BMap.Marker(point, &#123; icon: new BMap.Icon( require("../assets/img/marker.png"), new BMap.Size(40, 40), &#123; imageOffset: new BMap.Size(10, 10) &#125; ) &#125;); this.marker.enableDragging(); //marker可拖拽 this.map.addOverlay(this.marker); this.$emit("search", city); this.describeCircle(point, 5000); this.describeLabel(); &#125;, //距离查询 handleDistance() &#123; let value = this.distanceValue.trim() || 5; if (isNaN(value)) return; if (!this.marker) return; let point = this.marker.getPosition(); this.map.setCenter(point); this.describeCircle(point, value * 1000); this.isShowSearh = true; this.isShowDistance = false; &#125;, describeCircle(point, r) &#123; this.map.removeOverlay(this.circle); this.circle = new BMap.Circle(point, r, &#123; fillColor: "blue", strokeWeight: 1, fillOpacity: 0.2, strokeOpacity: 0.5 &#125;); this.map.addOverlay(this.circle); &#125;, describeLabel() &#123; let label = new BMap.Label("修改距离", &#123; offset: new BMap.Size(43, 20) &#125;); label.setStyle(&#123; border: "1px solid #ccc", width: "55px", height: "20px", textAlign: "center", lineHeight: "20px", zIndex: "1000", borderRadius: "5px" &#125;); this.marker.setLabel(label); label.addEventListener("click", () =&gt; &#123; this.isShowSearh = false; this.isShowDistance = true; this.inputValue = ""; &#125;); &#125;, 如图：]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中使用loadsh实现实时检索，使用箭头函数报错]]></title>
    <url>%2F2019%2F09%2F19%2Fvue%E4%B8%AD%E4%BD%BF%E7%94%A8loadsh%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E6%A3%80%E7%B4%A2%EF%BC%8C%E4%BD%BF%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[使用lodash插件实现input的实时检索，报错 使用npm下载ladash依赖后，引入lodash1import _ from 'lodash' 页面代码： 123&lt;div class="search"&gt; &lt;input type="text" v-model="condition" placeholder="搜索社区" v-on:input="lodashSearch"&gt;&lt;/div&gt; methods方法： 1234//实时检索lodashSearch: _.debounce(() =&gt; &#123; this.getSearchCommunity(); // 添加debounce，防止页面卡死&#125;, 400), 报错：this.this.getSearchCommunity is not a function 打印this为undefined 后面不使用箭头函数，则程序正常，不报错 1234 lodashSearch: _.debounce(function()&#123; console.log(this); //vue实例对象 this.getSearchCommunity(); // 添加debounce，防止页面卡死&#125;, 500), 但是我之前使用lodash做resize事件监听时，使用的是箭头函数，然后程序正常啊，代码如下： 123456mounted: function () &#123; let _ = require('lodash'); window.onresize = _.debounce(() =&gt; &#123; this.initPage(); // 添加debounce，防止页面卡死 &#125;, 400);&#125;, 为什么在 mounted 和 methods 里效果不一样呢？ 原因如下： methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例。 注意，不应该使用箭头函数来定义 method 函数 (例如 plus: () =&gt; this.a++)。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.a 将是 undefined。 示例： 12345678910111213var vm = new Vue(&#123; data: &#123; a: 1 &#125;, methods: &#123; plus: function () &#123; this.a++ &#125;, do()&#123; this.a--; &#125; &#125;&#125;)vm.plus()vm.a // 2]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双击和单击冲突问题]]></title>
    <url>%2F2019%2F09%2F16%2F%E5%8F%8C%E5%87%BB%E5%92%8C%E5%8D%95%E5%87%BB%E5%86%B2%E7%AA%81%2F</url>
    <content type="text"><![CDATA[同一个元素上，绑定多种事件类型，比较常见的是单击事件和一些鼠标事件，一般而言影响不大。但是如果同时绑定单击事件和双击事件呢？ 单击事件执行过程：mousedown, mouseup, click。双击事件的执行过程:mousedown, mouseup, click; mousedown, mouseup, click。仔细看，其实双击事件就是执行了两次单击事件，那这种情况下，怎么才能避免触发单击事件呢？ 解决问题的关键在于延迟定时器setTimeout，单击事件延迟执行，如果检测到连续点击的话，就认为是双击事件，不在执行单击事件。 12345678// 单击事件&lt;br&gt;var timer = null;let timer = null;$('.mask-body').on('click', '.leaver-student', function () &#123; // 点击输入框展开下拉列表 clearTimeout(timer); timer = setTimeout(function () &#123; // 这里采用执行自定义事件的方式 $('.leaver-student').trigger('slide'); &#125;, 300); // 延迟300ms执行单击事件&#125;); 1234567// 双击输入框时可以输入学生姓名 双击事件$('.mask-body').on('dblclick', '.leaver-student', function (ev) &#123; ev.stopPropagation(); clearTimeout(timer); $('.leavers li').trigger('click'); $(this).removeAttr('readonly').val('').focus();&#125;);]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度地图JavaScript API学习（一）]]></title>
    <url>%2F2019%2F09%2F05%2F%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BEJavaScript%20API%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[百度地图JavaScript API文档 简介 官方网址 http://lbsyun.baidu.com/index.php?title=jspopular 百度地图JavaScript API 是一套由JavaScript语言编写的应用程序接口，是百度目前为止功能最齐全的有关地图的网站。他能够帮助您在网站中构建功能丰富、交互性强的地图应用，包含了构建地图基本功能的各种接口，提供了诸如本地搜索、路线规划等数据服务。 该套API免费对外开放，自V1.5版本起，需要先申请密钥（AK）才可以使用，接口（除发送短信功能外），无使用次数限制。 JavaScript API首家支持Https，如需要申请Https服务，需要认证企业信息，成为企业认证用户后，https将自动开通，同时获得更高的服务配额。 使用方法 第一种：直接加载 第二种：异步加载 优点：功能多，提供可用的插件多 缺点：因为是针对js，而不是vue，所以需要自己封装。使用Vue Baidu Map 简介 这种是针对vue框架的一种地图，已经封装好。 官网地址 https://dafrok.github.io/vue-baidu-map/#/zh/index 使用方法 直接npm下载依赖就可以 优点：针对Vue的，一个封装好，直接粘贴复制就可以。 缺点：功能不全，只有百度地图JavaScript API地图的一部分内容，看项目需求，想我的项目用地图的比较多，这个网站满足不了，只能选择第一种。 使用vue-amap 简介 基于Vue 2.x与高德的地图组件，数据状态与地图状态单向绑定，开发者无需关心地图的具体操作【使用方法很简单，跟着官网走就可以了】 官方地址 https://elemefe.github.io/vue-amap/#/ 优点：跟Vue Baidu Map的一样，是针对Vue框架的，已经封装好的，可以直接使用 缺点：跟Vue Baidu Map的缺点一样，功能少JavaScript API 在 vue 中的具体使用方法 申请密钥 申请密钥（百度地图开放平台–&gt;开发文档–&gt;web开发–&gt;JavaScript API–&gt;立即使用–&gt;创建应用） 应用类型：浏览器端 Referer白名单：填*即可 密钥申请成功后即可使用密钥（AK） 第一种方法:直接引入script标签 除了引入script标签还不够，要想在vue文件中使用bmap对象，还需要在webpack的配置文件中，设置外部扩展（external属性） 1234//webpack.dev.conf.jsexternals:&#123; 'BaiduMap':'BMap'&#125; externals属性介绍： 防止将某些import的包（package)打包到bundle中，而是在运行时（runtime）再去从外部获取这些扩展依赖（external dependencies）。 在html 文件中引入百度地图API 1&lt;script type="text/javascript" src="http://api.map.baidu.com/api?v=2.0&amp;ak=密钥"&gt;&lt;/script&gt; 设置外部扩展(externals属性) 123456//webpack.dev.conf.jsexport default&#123; externals: &#123; 'BaiduMap': 'BMap' &#125;&#125; 添加dom结构 1&lt;div id="allmap"&gt;&lt;/div&gt; 直接使用百度地图的api 12345678910111213import BMap from 'BaiduMap'export default&#123; name:'Index', ...... mounted() &#123; var map = new BMap.Map("container"); // 创建地图实例 var point = new BMap.Point(116.404, 39.915); // 创建点坐标 map.centerAndZoom(point, 15); // 初始化地图，设置中心点坐标和地图级别 &#125;&#125; 第二种方法：通过模块化引入的方法 安装 1npm install vue-baidu-map --save 使用 全局注册(一次性引入百度地图组件库的所有组件) 1234567891011121314151617import Vue from 'vue';import BaiduMap from 'vue-baidu-map';Vue.use(BaiduMap,&#123; ak:'密钥'&#125;)&lt;template&gt; &lt;baidu-map class="bm-view"/&gt;&lt;/template&gt;&lt;style&gt;.bm-view&#123; width:100%; height:300px;&#125;&lt;/style&gt; 局部注册（按需引入组件） 123456789101112131415161718&lt;template&gt; &lt;baidu-map class="bm-view" ak="密钥"&gt;&lt;/baidu-map&gt;&lt;/template&gt;&lt;script&gt;import BaiduMap from 'vue-baidu-map/components/ map/Map.vue';export default&#123; components:&#123; BaiduMap &#125;&#125;&lt;/script&gt;&lt;style&gt;.bm-view &#123; width: 100%; height: 300px;&#125;&lt;/style&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Router]]></title>
    <url>%2F2019%2F09%2F05%2Freact-router%2F</url>
    <content type="text"><![CDATA[概念 React Router是一个基于React之上的强大路由库，它可以让你向应用中快速的添加视图和数据流，同时保持页面与URL间的同步。 安装 1npm install --save react-router 路由配置 12]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[状态提升]]></title>
    <url>%2F2019%2F09%2F04%2F%E7%8A%B6%E6%80%81%E6%8F%90%E5%8D%87%2F</url>
    <content type="text"><![CDATA[通常，多个组件需要反应相同的变化数据，这时我们建议将共享状态提升到最近的共同父组件中去，实现共享 state。这就是所谓的“状态提升”。 例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import React from "react";import ReactDOM from "react-dom";const scaleNames = &#123; c: "Celsius", f: "Fahrenheit"&#125;;function BoilingVerdict(props) &#123; if (props.celsius &gt;= 100) &#123; return &lt;p&gt;The water would boil.&lt;/p&gt;; &#125; return &lt;p&gt;The water would not boil.&lt;/p&gt;;&#125;function toCelsius(fahrenheit) &#123; return ((fahrenheit - 32) * 5) / 9;&#125;function toFahrenheit(celsius) &#123; return (celsius * 9) / 5 + 32;&#125;function tryConvert(temperature, convert) &#123; const input = parseFloat(temperature); if (Number.isNaN(input)) &#123; return ""; &#125; const output = convert(input); const rounded = Math.round(output * 1000) / 1000; return rounded.toString();&#125;class TemperatureInput extends React.Component &#123; constructor(props) &#123; super(props); this.handleChange = this.handleChange.bind(this); // this.state = &#123; temperature: "" &#125;; &#125; handleChange(e) &#123; // this.setState(&#123; temperature: e.target.value &#125;); this.props.onTemperatureChange(e.target.value); &#125; render() &#123; // const temperature = this.state.temperature; const temperature = this.props.temperature; const scale = this.props.scale; return ( &lt;fieldset&gt; &lt;legend&gt;Enter temperature in &#123;scaleNames[scale]&#125;&lt;/legend&gt; &lt;input value=&#123;temperature&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/fieldset&gt; ); &#125;&#125;class Calculator extends React.Component &#123; constructor(props) &#123; super(props); this.handleCelsiusChange = this.handleCelsiusChange.bind(this); this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this); this.state = &#123; temperature: "", scale: "c" &#125;; &#125; handleCelsiusChange(temperature) &#123; this.setState(&#123; scale: "c", temperature &#125;); &#125; handleFahrenheitChange(temperature) &#123; this.setState(&#123; scale: "f", temperature &#125;); &#125; render() &#123; const scale = this.state.scale; const temperature = this.state.temperature; const celsius = scale === "f" ? tryConvert(temperature, toCelsius) : temperature; const fahernheit = scale === "c" ? tryConvert(temperature, toFahrenheit) : temperature; return ( &lt;div&gt; &lt;TemperatureInput scale="c" temperature=&#123;celsius&#125; onTemperatureChange=&#123;this.handleCelsiusChange&#125; /&gt; 2 &lt;TemperatureInput scale="f" temperature=&#123;fahernheit&#125; onTemperatureChange=&#123;this.handleFahrenheitChange&#125; /&gt; &lt;BoilingVerdict celsius=&#123;parseFloat(celsius)&#125; /&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render(&lt;Calculator /&gt;, document.getElementById("root")); 组合有些组件无法提前知晓它们子组件的具体内容。在 Sidebar（侧边栏）和 Dialog（对话框）等展现通用容器（box）的组件中特别容易遇到这种情况。 123456789101112131415161718192021import React from "react";import ReactDOM from "react-dom";function FancyBorder(props)&#123; return ( &lt;div className=&#123;'FancyBorder FancyBorder-' + props.color&#125;&gt; &#123;props.children&#125; &lt;/div&gt; )&#125;function WelcomeDialog()&#123; return( &lt;FancyBorder color="blue"&gt; &lt;h1 className="Dialog-title"&gt;Weclome&lt;/h1&gt; &lt;p className="Dialog-message"&gt;Thanks&lt;/p&gt; &lt;/FancyBorder&gt; )&#125;ReactDOM.render(&lt;WelcomeDialog /&gt;, document.getElementById("root")); &lt;FancyBorder&gt; JSX 标签中的所有内容都会作为一个 children prop 传递给 FancyBorder 组件。因为 FancyBorder 将 {props.children} 渲染在一个 &lt;div&gt; 中，被传递的这些子组件最终都会出现在输出结果中。 不可变性一般来说，有两种改变数据的方式。第一种方式是直接修改变量的值，第二种方式是使用新的一份数据替换旧数据。 跟踪不可变数据的变化相对来说就容易多了。如果发现对象变成了一个新对象，那么我们就可以说对象发生改变了。 确定在React中何时重新渲染 不可变性最主要的优势在于它可以帮助我们在React中创建pure components。我们可以很轻松的确定不可变数据是否发生了变化，从而确定何时对组件进行重新渲染。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[列表&表单]]></title>
    <url>%2F2019%2F09%2F04%2Freact-%E5%88%97%E8%A1%A8%26%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"><![CDATA[基础列表组件通过使用 {} 在 JSX 内构建一个元素集合,使用 Javascript 中的 map() 方法来遍历 numbers 数组。将数组中的每个元素变成 li 标签，最后我们将得到的数组赋值给 listItems： 12345678910111213141516171819202122232425function ListItem(props) &#123; // 正确！这里不需要指定 key： return &lt;li&gt;&#123;props.value&#125;&lt;/li&gt;;&#125;function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; // 正确！key 应该在数组的上下文中被指定 &lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt; ); return ( &lt;ul&gt; &#123;listItems&#125; &lt;/ul&gt; );&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125; /&gt;, document.getElementById('root')); 注意：key 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。 一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用来自数据 id 来作为元素的 key，当元素没有确定 id 的时候，万不得已你可以使用元素索引 index 作为 key。 表单在 React 里，HTML 表单元素的工作方式和其他的 DOM 元素有些不同，这是因为表单元素通常会保持一些内部的 state。 受控组件 123456789101112131415161718192021222324252627282930class NameForm extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;value: ''&#125;; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); &#125; handleChange(event) &#123; this.setState(&#123;value: event.target.value&#125;); &#125; handleSubmit(event) &#123; alert('提交的名字: ' + this.state.value); event.preventDefault(); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; 名字: &lt;input type="text" value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/label&gt; &lt;input type="submit" value="提交" /&gt; &lt;/form&gt; ); &#125;&#125; HTML表单input里面的value有什么用: input标签有很多类型，也就是type，以下是一些常用type的说明 text：文本框，input默认的type，不写就是这个，value表示文本框里的值。 password：密码框，value表示密码框里的值。 submit：提交按钮，value表示按钮上的文字 button：普通按钮，value表示按钮上的文字 reset：重置按钮，value表示按钮上的文字 radio：单选框，value表示该单选框的真实值（一般真实值和数据库对应，显示的值给用户参考的） checkbox：复选框，value表示该复选框的真实值 hindden：隐藏表单域，value表示该表单域的值。 处理多个输入 当需要处理多个input元素时u，我们可以给每个元素添加name属性，并让处理函数根据event.target.name的值选择要执行的操作。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React事件处理]]></title>
    <url>%2F2019%2F09%2F03%2Freact%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[React 事件的命名采用小驼峰式（camelCase），而不是纯小写。 使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。 123&lt;button onClick=&#123;activeLasers&#125;&gt; 点击&lt;/button&gt; 阻止默认事件 123456789101112function ActionLink()&#123; function handleClick(e)&#123; e.preventDefault(); console.log("The link was clicked."); &#125;&#125;return ( &lt;a href="#" onClick=&#123;handleClick&#125;&gt; 点击 &lt;/a&gt;) 一个简单的开关切换的例子： 12345678910111213141516171819202122232425262728293031323334class Toggle extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;isToggleOn:true&#125;; //为了在回调中使用“this”,这个绑定是必不可少的 this.handleClick = this.handleClick.bind(this); &#125; handleClick()&#123; this.setState(state =&gt; (&#123; isToggleOn:!state.isToggleOn &#125;)); &#125; //this解决方案，也可以使用箭头函数 // handleClick = () =&gt; &#123; // console.log('this is ',this); // &#125; render()&#123; return ( // &lt;button onClick=&#123;this.handleClick&#125;&gt; // &#123;this.state.isToggleOn ? 'ON' : 'OFF'&#125; // &lt;/button&gt; &lt;button onClick=&#123;(e)=&gt;this.handleClick(e)&#125;&gt; Click me &lt;/button&gt; ); &#125;&#125;ReactDom.render( &lt;Toggle /&gt;, document.getElementById('root')); 我们通常建议在构造器中绑定或使用 class fields 语法来避免这类性能问题。 向事件处理程序传递参数 在循环中，通常我们会为事件处理函数床底额外的参数，例如删除指定id的行，有以下两种方式： 12&lt;button onClick=&#123;(e)=&gt;this.deleteRow(id,e)&#125;&gt;Delete Row&lt;/button&gt;&lt;button onClick=&#123;this.deleteRow.bind(this,id)&#125;&gt;Delete Row&lt;/button&gt; 在这两种情况下，React的事件对象e会被作为第二个参数传递。如果通过箭头函数的方式，事件对象必须显示的进行传递，而通过bind的方式，事件对象以及更多的参数将会被隐式的进行传递。 条件渲染1234567891011121314151617181920212223242526import React from "react";import ReactDOM from "react-dom";function UserGreeting(props)&#123; return &lt;h1&gt;Welcome back!&lt;/h1&gt;&#125;function GuestGreeting(props)&#123; return &lt;h1&gt;Please sign up.&lt;/h1&gt;&#125;function Greeting(props)&#123; const isLoggedIn = props.isLoggedIn; // if(isLoggedIn)&#123; // return &lt;UserGreeting/&gt; // &#125; // return &lt;GuestGreeting/&gt; //三目写法 return isLoggedIn ? &lt;UserGreeting/&gt; : &lt;GuestGreeting/&gt;&#125;ReactDOM.render( &lt;Greeting isLoggedIn=&#123;true&#125;/&gt;, document.getElementById('root')) 元素变量]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[State学习]]></title>
    <url>%2F2019%2F09%2F03%2Freact-state%2F</url>
    <content type="text"><![CDATA[State 和生命周期 将函数组件转换成class组件 123456789101112131415161718192021class Clock extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123; date:new Date() &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;h1&gt;Hello,World&lt;/h1&gt; &lt;h2&gt;It is &#123;this.props.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ) &#125;&#125;ReactDom.render( &lt;Clock /&gt;, document.getElementById('root')); 生命周期 componentWillMount 在渲染前调用,在客户端也在服务端。 componentDidMount : 在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异步操作阻塞UI)。 componentWillReceiveProps 在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化render时不会被调用。 shouldComponentUpdate 返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用。可以在你确认不需要更新组件时使用。 componentWillUpdate在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。 componentDidUpdate 在组件完成更新后立即调用。在初始化时不会被调用。 componentWillUnmount在组件从 DOM 中移除之前立刻被调用 将生命周期方法添加到class 12345678910componentDidMount()&#123; this.timer = setInterval( () =&gt; this.tick(), 1000 )&#125;componentWillUnmount()&#123; clearInterval(this.timerID)&#125; 使用this.setState()来更新state: 12345tick()&#123; this.setState(&#123; date:new Date() &#125;)&#125; State的使用 不要直接修改state,要通过this.setState()修改 123this.state.comment = 'Hello'; //错误的this.setState(&#123;comment:'Hello'&#125;); //正确 构造函数是唯一可以给this.state赋值的地方 State的更新可能是异步的 State的更新会被合并 当你调用setState()的时候，React会把你提供的对象合并到当前的state。 数据是向下流动的]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React组件学习]]></title>
    <url>%2F2019%2F09%2F03%2Freact%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[组件，类似于JavaScript函数，它接受任意的入参（即“props”），并返回用于描述页面展示内容的React元素。 函数组件与class组件 第一种函数组件 该函数接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素。 123function Welcome(props)&#123; return &lt;h1&gt;Hello,&#123;props.name&#125;&lt;/h1&gt;&#125; 第二种class组件 12345class Welcome extends React.Component&#123; render()&#123; return &lt;h1&gt;Hello,&#123;this.props.name&#125;&lt;/h1&gt; &#125;&#125; 当React元素为用户自定义组件时，它会将JSX所接收的属性（attribute)转换为单个对象传递给组件，这个对象被称之为“props”。 例如： 123456789function Welcome(props)&#123; return &lt;h1&gt;Hello,&#123;props.name&#125;&lt;/h1&gt;;&#125;const element = &lt;Welcome name = "Sera" /&gt;ReactDOM.render( element, doeument.getElementById('root')) 在此Welcome组件被调用时，将{name:’Sera’}作为props传入。Welcome组件将Hello,Sera元素作为返回值。 注意:组件名称必须以大写字母开头，且需要在作用域内使用组件。 组合组件组件可以在其输出中引用其他组件，这就可以让我们用同一组件来抽象出任意层次的细节，在react应用程序中，整个屏幕的内容都会以组件的形式表示。 1234567891011121314151617function Welcome(props)&#123; return &lt;h1&gt;Hello,&#123;props.name&#125;&lt;/h1&gt;;&#125;function App()&#123; return ( &lt;div&gt; &lt;Welcome name="Sera"/&gt; &lt;Welcome name="Cahal"/&gt; &lt;Welcome name="Edit"/&gt; &lt;/div&gt; )&#125;ReactDom.render( &lt;App /&gt;, document.getElementByid('root')) 提取组件将组件拆分为更小的组件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// Avatar组件function Avatar(props)&#123; return( &lt;img className="Avatar" src=&#123;props.user.avatarUrl&#125; alt=&#123;props.user.name&#125; /&gt; )&#125;function Comment(props)&#123; return ( &lt;div className="Comment"&gt; &lt;div className="UserInfo"&gt; &lt;Avatar user=&#123;props.author&#125;/&gt; &lt;div className="UserInfo-name"&gt; &#123;props.author.name&#125; &lt;/div&gt; &lt;/div&gt; &lt;div className="Comment-text"&gt; &#123;props.text&#125; &lt;/div&gt; &lt;div className="Comment-data"&gt; &#123;formatData(props.date)&#125; &lt;/div&gt; &lt;/div&gt; )&#125;// UserInfo组件function UserInfo(props)&#123; return ( &lt;div className="UserInfo"&gt; &lt;Avatar user=&#123;props.user&#125;/&gt; &lt;div className="UserInfo-name"&gt; &#123;props.user.name&#125; &lt;/div&gt; &lt;/div&gt; )&#125;function Comment(props)&#123; return ( &lt;div className="comment"&gt; &lt;UserInfo user=&#123;props.author&#125;/&gt; &lt;div className="Comment-text"&gt; &#123;props.text&#125; &lt;/div&gt; &lt;div className="Comment-date"&gt; &#123;formatDate(props.date)&#125; &lt;/div&gt; &lt;/div&gt; )&#125; 注意：所有的react组件都必须像纯函数一样保护它们的props不被更改。 如果你想写的组件只包含一个 render 方法，并且不包含 state，那么使用函数组件就会更简单。我们不需要定义一个继承于 React.Component 的类，我们可以定义一个函数，这个函数接收 props 作为参数，然后返回需要渲染的元素。函数组件写起来并不像 class 组件那么繁琐，很多组件都可以使用函数组件来写。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex学习]]></title>
    <url>%2F2019%2F08%2F27%2Fvuex%E5%AE%9E%E6%88%98%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[安装 123npm install vuex --save//或yarn add vuex 使用步骤 创建store文件夹 1234567891011121314151617181920//store/store.jsimport Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export const store = new Vuex.Store(&#123; state: &#123; products: [ &#123; name: "马云", price: 200 &#125;, &#123; name: "马化腾", price: 100 &#125;, &#123; name: "马冬梅", price: 20 &#125;, &#123; name: "马蓉", price: 10 &#125; ] &#125;&#125;);//注意new Vuex.Store的Store的S是大写，否则报错为Uncaught TypeError: vuex__WEBPACK_IMPORTED_MODULE_1__.default.store is not a constructor 在main.js中引入store 1234567import &#123;store&#125; from './store/store';new Vue(&#123; store, el:"#app", render:h =&gt; h(App)&#125;) 使用数据 123456789//在组件中//product-list-one.vue中利用computed属性获取store中的数据export default &#123; computed:&#123; products()&#123; return this.$store.state.products; &#125; &#125;&#125; 在完成数据初步渲染之后在组件一种实现改变商品价格的操作首先获取需要改变的数据，然后在计算属性中对数据进行改变 1234567891011121314151617computed: &#123; products() &#123; return this.$store.state.products; &#125;, saleProducts() &#123; let saleProducts = this.$store.state.products.map(product =&gt; &#123; return &#123; name: "**" + product.name + "**", price: product.price / 2 &#125;; &#125;); return saleProducts; &#125; &#125; //将遍历对象改为saleProducts &lt;li v-for="(item,index) in saleProducts" :key="index"&gt;&lt;/li&gt; 但对于多个组价共用次方法则多次复制比较麻烦，需改为以下方式将方法抽离到store.js中的getters 在store.js中 1234567891011getters:&#123; saleProducts:(state) =&gt; &#123; let saleProducts = state.products.map(product =&gt; &#123; return &#123; name: "**" + product.name + "**", price: product.price / 2 &#125;; &#125;); return saleProducts; &#125; &#125; 实现商品降价功能 在vue中只需在methods中添加一个方法 1234567methods:&#123; reducePrice()&#123; this.$store.state.products.forEach(product =&gt; &#123; product.price -= 1; &#125;) &#125;&#125; 更改Vuex的store中的状态的唯一方法是提交mutation,Vuex中的mutation非常类似于事件，没个mutation都有一个字符串的事件类型[type]和一个回调函数，这个回调函数就是我们实际运行状态更改的地方，并且他会接受state作为第一个参数。 一般在触发事件时才使用mutation，如果是想要获取数据时就使用getters,想要存储数据时就用state， 12345678910111213141516//store.js//触发事件，改变数据 mutations: &#123; reducePrice: state =&gt; &#123; state.products.forEach(product =&gt; &#123; product.price -= 1; &#125;); &#125; &#125;//在组件中使用时用commit激活事件，事件触发的事件名字要与store中的事件名字相同methods: &#123; reducePrice() &#123; this.$store.commit("reducePrice"); &#125; &#125; vueX还兼容严格模式。 ActionsActions提交的是mutation，而不是直接变更的数据状态。 如果实现异步操作应该在Action中实现。 Action是通过store.dispatch触发的。 1234567891011121314151617//store/store.jsactions: &#123; reducePrice: context =&gt; &#123; setTimeout(() =&gt; &#123; context.commit("reducePrice"); &#125;, 2000); &#125; &#125;//组件中 methods: &#123; reducePrice() &#123; // this.$store.commit("reducePrice"); //此处commit是直接触发mutation中的方法 // 此处应调用actions里的方法 this.$store.dispatch("reducePrice"); //事件名对应store中actions中的方法名 &#125; &#125; Actions 可以进行传参 组件方法中将参数写到分发事件后进行传递，store中通过payload参数进行接收。 123456789101112131415161718192021222324//store.js//触发事件，改变数据 mutations: &#123; reducePrice: (state,payload) =&gt; &#123; state.products.forEach(product =&gt; &#123; product.price -= payload; &#125;); &#125; &#125;, actions: &#123; reducePrice: (context, payload) =&gt; &#123; setTimeout(() =&gt; &#123; context.commit("reducePrice",payload); &#125;, 2000); &#125; &#125;//组件中 methods: &#123; reducePrice(amount) &#123; // this.$store.commit("reducePrice"); //此处commit是直接触发mutation中的方法 // 此处应调用actions里的方法 this.$store.dispatch("reducePrice",amount); //事件名对应store中actions中的方法名 &#125; &#125; 辅助函数 mapGettersmapGetters辅助函数仅仅是将store中的getters映射到局部计算属性； mapActionsmapActions辅助函数将组件的methods映射为store.dispatch调用，需要先在根节点注入store， 1234567891011121314151617181920212223242526&lt;script&gt;import &#123;mapGetters&#125; from 'vuex'import &#123;mapActions&#125; from 'vuex'export default &#123; computed:&#123; products()&#123; return this.$store.state.products; &#125;, ...mapGetters([ "saleProducts" ]) &#125;, methods:&#123; ...mapActions([ "reducePrice" ]) &#125;&#125;&lt;/script&gt;//如果你想将一个 getter 属性另取一个名字，使用对象形式：mapGetters(&#123; doneCount:"doneTodosCount"&#125;)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue学习（五）]]></title>
    <url>%2F2019%2F08%2F27%2Fvue%E4%B8%AD%E4%BD%BF%E7%94%A8less%2F</url>
    <content type="text"><![CDATA[vue中使用less 安装less安装包 npm install less less-loader -D 在build文件夹下的webpack.base.conf.js的rules里面添加配置123456modules:&#123; rules:&#123; test:/\.less$/, loader:"style-loader！css-loader!less-loader", &#125;&#125; 最后在代码中的style标签中加上lang=”less”属性即可或者是 1&lt;style type="text/less" lang="less" rel="stylesheet/less" scoped&gt; vue中使用sass 安装sass安装包 12345npm install sass-loader -D//sass-loader依赖于node-sassnpm install -D node-sass 在build文件夹下的webpack.base.conf.js的rules里面添加配置 123456modules:&#123; rules:&#123; test:/\.sass$/, loaders:['style','css','sass'] &#125;&#125; 最后在代码中的style标签中加上lang=”scss”属性即可或者是 1&lt;style type="text/scss" lang="scss" rel="stylesheet/scss" scoped&gt; 路由——vue-router实际开发中App.vue只是作为一个存放组件的容器，其中是用来渲染通过路由映射过来的组件，当路劲更改时，中的内容会发生改变， 用映射路由。 vue-routerVue.js 路由允许我们通过不同的 URL 访问不同的内容。 通过 Vue.js 可以实现多视图的单页Web应用（single page web application，SPA）。 Vue.js 路由需要载入 vue-router 库.安装1、直接下载 / CDNhttps://unpkg.com/vue-router/dist/vue-router.js2、NPM推荐使用淘宝镜像： 1cnpm install vue-router router-link 是一个组件，该组件用于设置一个导航链接，切换不同 HTML 内容。 to 属性为目标地址， 即要显示的内容。当被点击后，内部会立刻把 to 的值传到 router.push()，所以这个值可以是一个字符串或者是描述目标位置的对象。 12345678910111213141516171819&lt;!-- 字符串 --&gt;&lt;router-link to="home"&gt;Home&lt;/router-link&gt;&lt;!-- 渲染结果 --&gt;&lt;a href="home"&gt;Home&lt;/a&gt;&lt;!-- 使用 v-bind 的 JS 表达式 --&gt;&lt;router-link v-bind:to="'home'"&gt;Home&lt;/router-link&gt;&lt;!-- 不写 v-bind 也可以，就像绑定别的属性一样 --&gt;&lt;router-link :to="'home'"&gt;Home&lt;/router-link&gt;&lt;!-- 对象形式 --&gt;&lt;router-link :to="&#123; path: 'home' &#125;"&gt;Home&lt;/router-link&gt;&lt;!-- 命名的路由 --&gt;&lt;router-link :to="&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;"&gt;User&lt;/router-link&gt;&lt;!-- 带查询参数，下面的结果为 /register?plan=private --&gt;&lt;router-link :to="&#123; path: 'register', query: &#123; plan: 'private' &#125;&#125;"&gt;Register&lt;/router-link&gt; 12345678910111213141516&lt;script src="https://unpkg.com/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script src="https://unpkg.com/vue-router/dist/vue-router.js"&gt;&lt;/script&gt; &lt;div id="app"&gt; &lt;h1&gt;Hello App!&lt;/h1&gt; &lt;p&gt; &lt;!-- 使用 router-link 组件来导航. --&gt; &lt;!-- 通过传入 `to` 属性指定链接. --&gt; &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt; &lt;router-link to="/foo"&gt;Go to Foo&lt;/router-link&gt; &lt;router-link to="/bar"&gt;Go to Bar&lt;/router-link&gt; &lt;/p&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; vue-router使用步骤： 1234567891011121314151617181920212223242526// 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)// 1. 定义 (路由) 组件。// 可以从其他文件 import 进来const Foo = &#123; template: '&lt;div&gt;foo&lt;/div&gt;' &#125;const Bar = &#123; template: '&lt;div&gt;bar&lt;/div&gt;' &#125;// 2. 定义路由// 每个路由应该映射一个组件。 其中"component" 可以是// 通过 Vue.extend() 创建的组件构造器, 或者，只是一个组件配置对象。const routes = [ &#123; path: '/foo', component: Foo &#125;, &#123; path: '/bar', component: Bar &#125;]// 3. 创建 router 实例，然后传 `routes` 配置// 你还可以传别的配置参数const router = new VueRouter(&#123; routes // (缩写) 相当于 routes: routes&#125;)// 4. 创建和挂载根实例。// 记得要通过 router 配置参数注入路由， 从而让整个应用都有路由功能const app = new Vue(&#123; router&#125;).$mount('#app') 动态路由匹配我们经常需要将具有给定模式的路线映射到同一个组件。例如，我们可能有一个User应该为所有用户呈现但具有不同用户ID的组件。在vue-router我们可以在路径中使用动态段以实现： 12345678910const User = &#123; template: '&lt;div&gt;User&lt;/div&gt;'&#125;const router = new VueRouter(&#123; routes: [ // dynamic segments start with a colon &#123; path: '/user/:id', component: User &#125; ]&#125;) 这样，网址/user/foo和/user/bar将映射到相同的路由。动态段由冒号表示:。匹配路径时，动态段的值将this.$route.params在每个组件中公开。因此，我们可以通过更新User模板来呈现当前用户ID ： 123const User = &#123; template: '&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;'&#125; 通过注入路由器，我们可以访问它this.$router以及this.$route任何组件内部的当前路由： 123456789101112131415export default &#123; computed: &#123; username () &#123; // We will see what `params` is shortly return this.$route.params.username &#125; &#125;, methods: &#123; goBack () &#123; window.history.length &gt; 1 ? this.$router.go(-1) : this.$router.push('/') &#125; &#125;&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue学习（四）]]></title>
    <url>%2F2019%2F08%2F27%2Fvue%E4%B8%AD%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%2F</url>
    <content type="text"><![CDATA[vue中路由传参 使用router-link进行路由导航，传递参数 父组件中使用标签进行导航 12//child是子页面路由路径，123是需要传递的参数&lt;router-link to="/child/123"&gt;click&lt;/router-link&gt; 子组件中使用this.$route.params.num来接收路由参数 12345678910111213141516171819&lt;template&gt; &lt;div class="child"&gt; &#123;&#123;num&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default&#123; name:'child', data()&#123; return&#123; num:0, &#125; &#125;, mounted()&#123; this.num = this.$route.params.num &#125; &#125;&lt;/script&gt; 路由配置文件router/index.js 12345&#123; path:'/child/:num', // num用来为参数占位 name:'child', component:child&#125; 地址：localhost:8080/#/child/123 直接调用$router.push 实现携带参数的跳转 父组件 1234567891011121314151617181920212223&lt;template&gt; &lt;ul&gt; &lt;li v-for="itemId in 3" :key="itemId" @click="toChild(itemId)"&gt;&#123;&#123;itemId&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;// 模板渲染中调用函数，传递参数&lt;script&gt; export default&#123; name:'home', data()&#123; return&#123; num:0, &#125; &#125;, methods:&#123; toChild(id)&#123; this.$router.push(&#123; path:`/child/$&#123;id&#125;` &#125;) &#125; &#125; &#125;&lt;/script&gt; 子组件中： 12345&lt;template&gt; &lt;div class="child"&gt; &#123;&#123;this.$route.params.id&#125;&#125; &lt;/div&gt;&lt;/template&gt; 路由配置文件中： 12345&#123; path:'/child/:id', //id用来为参数占位 name:'child', component:Child&#125; 地址：localhost:8080/#/child/1 通过路由属性中的name来确定匹配的路由，通过params来传递参数 父组件： 123456789101112131415161718192021222324&lt;template&gt; &lt;button @click="toClick"&gt;click&lt;/button&gt;&lt;/template&gt;&lt;script&gt; export default&#123; name:'home', data()&#123; return&#123; num:0, &#125; &#125;, methods:&#123; toChild()&#123; this.$router.push(&#123; //使用name来匹配路由 name:'childView', params:&#123; id:1 &#125; &#125;) &#125; &#125; &#125;&lt;/script&gt; 子组件中： 12345&lt;template&gt; &lt;div class="child"&gt; &#123;&#123;this.$route.params.id&#125;&#125; &lt;/div&gt;&lt;/template&gt; 路由配置问件中： 12345&#123; path:'/child', name:'childView', cmponent:Child,&#125; 地址：localhost:8080/#/child 使用path来匹配路由，然后通过query来传递参数，这种情况下 query传递的参数会显示在url后面?id=？ 父组件中： 123456789101112131415161718192021222324 &lt;template&gt; &lt;button @click="toClick"&gt;click&lt;/button&gt;&lt;/template&gt;&lt;script&gt; export default&#123; name:'home', data()&#123; return&#123; num:0, &#125; &#125;, methods:&#123; toChild()&#123; this.$router.push(&#123; //使用name来匹配路由 path:"/child", query:&#123; id:1 &#125; &#125;) &#125; &#125; &#125;&lt;/script&gt; 子组件中： 12345 &lt;template&gt; &lt;div class="child"&gt; &#123;&#123;this.$route.params.id&#125;&#125; &lt;/div&gt;&lt;/template&gt; 路由配置文件中： 12345&#123; path:'/child', name:'child', component:Child,&#125; 地址：localhost:8080/#/child?id=1 总结： this.$router.push进行编程式路由跳转 router-link 进行页面按钮式路由跳转 this.$route.params获取路由传递参数 this.$route.query获取路由传递参数 params 和 query 都是传递参数的，params不会在url上面出现，并且params参数是路由的一部分，是一定要存在的 query则是我们通常看到的url后面的跟在？后面的显示参数]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue学习（三）]]></title>
    <url>%2F2019%2F08%2F27%2Fvue%E4%B8%AD%E4%BD%BF%E7%94%A8mock%2F</url>
    <content type="text"><![CDATA[vue中使用mockMock.js 是一个模拟数据生成器，利用它，可以拦截ajax请求，直接模拟返回数据，这样前后端只要约定好数据格式，前端就不需要依赖后端的接口，可以直接使用模拟的数据了。这里介绍在Vue工程中使用Mockjs。在用mock进行假数据模拟时，不同模块可能会用到相同模块的mock，为了对mock同样较好的工程化管理，公用的mock会写在index里，而各自模块会单独创建文件。 安装 1npm install --save-dev mockjs index.js内容 123456789101112131415import Mock from "mockjs";import &#123; createMock &#125; from "./utils";import User from "./modules/user";// 设置所有ajax请求的超时时间，模拟网络传输耗时Mock.setup(&#123; timeout: 2000&#125;);createMock(Mock, User);export default Mock; utils.js文件 12345678910111213141516/** * createMock 创建mock方法 * @param Mock Mock对象 * @param module 当前module */const createMock = (Mock, module) =&gt; &#123; if (module.length &gt; 0) &#123; module.map((item) =&gt; &#123; Mock.mock(item.rurl, item.rtype.toLowerCase(), item.template || item.callback) &#125;) &#125;&#125;export &#123; createMock&#125; 拦截ajax请求，配置mock的数据 拦截ajax请求主要可以使用Mock中的两个方法： 1. Mock.mock( rurl, rtype, template ) 2. Mock.mock( rurl, rtype, function( options ) ) rurl：表示需要拦截的 URL，可以是 URL 字符串或 URL 正则。例如： 12/\/domain\/list\.json/'/domian/list.json' rtype：表示需要拦截的 Ajax 请求类型。例如 GET、POST等。 template：表示数据模板，可以是对象(obj)或字符串(string)。如果需要要把数据写死，可以直接写一个普通的对象。如果要让Mock随机生成，可以根据Mock模板的规则自定义。例如： 123&#123; ‘data|1-10’:[&#123;&#125;] &#125; 表示生成生成包含 1到10个空对象的数据‘@EMAIL’ 表示随机生成一个email地址‘@CNAME’ 表示随机生成一个中文人名 Stylus基本使用CSS 预处理，顾名思义，预先处理 CSS。那 stylus 咋预先处理呢？stylus 给 CSS 添加了可编程的特性，也就是说，在 stylus 中可以使用变量、函数、判断、循环一系列 CSS 没有的东西来编写样式文件，执行这一套操作之后，这个文件可编译成 CSS 文件。 安装1npm install stylus 安装之后，运行 stylus -h 可查看帮助。 运行 stylus example.styl 可将 demo.styl 文件编译成 example.css 文件。 基本使用 stylus代码： 123456789101112131415$background-color = lightblueadd (a, b = a) a = unit(a, px) b = unit(b, px) a + b.list-item.text-box span background-color: $background-color margin: add(10) padding: add(10, 5) &amp;:hover background-color: powderblue 编译后生成的 CSS 代码： 12345678910.list-item span,.text-box span &#123; background-color: #add8e6; margin: 20px; padding: 15px&#125;.list-item:hover,.text-box:hover &#123; background-color: #b0e0e6;&#125; 变量 $background-color = lightblue 上面的代码声明了变量 $background-color,并为其赋值 lightblue。 声明之后，就可以使用这个变量了： 12span background-color: $background-color 翻译成 CSS 就是： 123span&#123; background-color: lightblue;&#125; 函数 1234add (a, b = a) a = unit(a, px) b = unit(b, px) a + b 代码声明了函数 add, add 接受两个参数 a 和 b，其中 b 的默认值是 a。 add 中调用了 stylus 的内置函数 unit，此处，unit 函数为 a 和 b赋予了单位 px。最后将 a 和 b 相加，并返回结果，是的，你没有看错，没有 return，但是返回了结果。 函数调用： 123span margin: add(10) padding: add(10, 5) 翻译成 CSS 就是： 1234span &#123; margin: 20px; padding: 15px;&#125; 选择器 12345678.list-item.text-box span background-color: $background-color margin: add(10) padding: add(10, 5) &amp;:hover background-color: powderblue 先说符号，这里提到的花括号和分号在stylus中是可以省略的，不仅如此，冒号也是可以省略的，color: powderblue 你可以写成 color powderblue,没有问题。 再说缩进，先提出两个有缩进关系的选择器，上面代码片段第二行的 .text-box 和第三行的 span，其实很容易理解，这哥俩写到 CSS 里面是这样的： .text-box span{ ... } 即 span 是 .text-box 的子选择器，stylus 中以缩进表示这种关系，更加清晰明了，好看。 &amp;是父级的引用。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue学习（二）]]></title>
    <url>%2F2019%2F08%2F27%2Fvue%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[父子组件传值 父组件向子组件传值 父向子传递数据通过props 父组件代码: 1234567891011121314151617&lt;template&gt; &lt;header-box :title-txt="showTitleTxt"&gt;&lt;/header-box&gt;&lt;/template&gt;&lt;script&gt; import Header from './header' export default &#123; name: 'index', components: &#123; 'header-box': Header &#125;, data () &#123; return &#123; showTitleTxt: '首页' &#125; &#125; &#125;&lt;/script&gt; 子组件代码: 123456789101112131415161718&lt;template&gt; &lt;header&gt; &#123;&#123;thisTitleTxt&#125;&#125; &lt;/header&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: 'header-box', props: &#123; titleTxt: String &#125;, data () &#123; return &#123; thisTitleTxt: this.titleTxt &#125; &#125; &#125;&lt;/script&gt; 子组件向父组件传值 子组件向父组件传递分为两种类型。 1、子组件改变父组件传递的props（你会发现通过props中的Object类型参数传输数据，可以通过子组件改变数据内容。这种方式是可行的，但是不推荐使用，因为官方定义prop是单向绑定） 2、通过$on和$emit 通过props实现传递 父组件代码 12345678910111213141516171819&lt;template&gt; &lt;header-box :title-txt="showTitleTxt"&gt;&lt;/header-box&gt;&lt;/template&gt;&lt;script&gt; import Header from './header' export default &#123; name: 'index', components: &#123; 'header-box': Header &#125;, data () &#123; return &#123; showTitleTxt: &#123; name: '首页' &#125; &#125; &#125; &#125;&lt;/script&gt; 子组件代码: 1234567891011121314151617181920212223&lt;template&gt; &lt;header @click="changeTitleTxt"&gt; &#123;&#123;thisTitleTxt.name&#125;&#125; &lt;/header&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: 'header-box', props: &#123; titleTxt: Object &#125;, data () &#123; return &#123; thisTitleTxt: this.titleTxt.name &#125; &#125;, metheds: &#123; changeTitleTxt () &#123; this.titleTxt.name = '切换' &#125; &#125; &#125;&lt;/script&gt; 通过$on,$emit 父组件代码 12345678910111213141516171819202122232425&lt;template&gt; &lt;div id="counter-event-example"&gt; &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;button-counter v-on:increment="incrementTotal"&gt;&lt;/button-counter&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; import ButtonCounter from './buttonCounter' export default &#123; name: 'index', components: &#123; 'button-conuter': ButtonCounter &#125;, data () &#123; return &#123; total: 0 &#125; &#125;, methods: &#123; incrementTotal () &#123; this.total++ &#125; &#125; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue学习（一）]]></title>
    <url>%2F2019%2F08%2F27%2Fvue%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[安装12345678910// 安装最新版本npm install -g @vue/cli# ORyarn global add @vue/cli// 查看版本号vue --version# ORvue -V// + @vue/cli@3.10.0 创建新项目 2.9.6 版本 12345678910// 创建新项目vue init webpack vue-projectcd vue-project// 安装依赖npm install// 启动项目npm run dev 3.10.0 版本 123456// 创建新项目 vue create hello-world // 启动项目 $ cd hello-world $ yarn serve 2.9.6 版本 3.10.0 版本 使用图形化界面 通过 vue ui 命令以图形化界面创建和管理项目： 1vue ui 基础知识 v-if 和 v-show 的区别 相同点：v-if与v-show都可以动态控制dom元素显示隐藏 不同点：v-if显示隐藏是将dom元素整个添加或删除会触发回流和重绘，而v-show隐藏则是为该元素添加css–display:none，dom元素还在。 如果有频繁的切换，会首选v-show,减少对dom的频繁操作。 v-for 指令 v-for 指令需要以item in list 形式的特殊语法，list是源数据组并且item数组元素迭代的别名。 v-for 可以绑定数据到数组渲染一个列表： 1234567891011121314151617181920&lt;div id="app"&gt; &lt;ol&gt; &lt;li v-for="site in sites"&gt; &#123;&#123; site.name &#125;&#125; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; &lt;script&gt;new Vue(&#123; el: '#app', data: &#123; sites: [ &#123; name: 'Runoob' &#125;, &#123; name: 'Google' &#125;, &#123; name: 'Taobao' &#125; ] &#125;&#125;)&lt;/script&gt; 注意使用v-for时都必须会加上一个必要的key值，可以使用index作为key,但这样不太好，应该给每一条数据应该唯一的标识id，使用v-for更新已渲染的元素列表时,默认用就地复用策略;列表数据修改的时候,他会根据key值去判断某个值是否修改,如果修改,则重新渲染这一项,否则复用之前的元素。 vue 生命周期 Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。 每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段：初始化、运行中、销毁。 beforeCreate: 在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。 created: 在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 beforeMount: 在挂载开始之前被调用：相关的 render 函数首次被调用,接下来开始找实例或者组件对应的模板，编译模板为虚拟dom放入到render函数中准备渲染。 mounted：el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。接下来开始render，渲染出真实dom，此时，组件已经出现在页面中，数据、真实dom都已经处理好了,事件都已经挂载好了，可以在这里操作真实dom等事情… beforeUpdate：数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。 updated：当由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。 beforeDestroy：当经过某种途径调用$destroy方法后，实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 生命周期图示:]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Vue项目中使用vw实现移动端适配]]></title>
    <url>%2F2019%2F08%2F27%2F%E5%9C%A8Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8vw%E5%AE%9E%E7%8E%B0%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[直接使用Vue官方提供的Vue-cli的构建工具来构建Vue项目。1234567891011//首先需要安装Vue-cli：npm install -g vue-cli//构建项目：vue create project//运行项目cd projectyarn serve//在浏览器执行http://localhost:8080，就可以看以默认的页面效果 安装PostCSS插件 1npm i -S postcss-import postcss-url postcss-aspect-ratio-mini postcss-px-to-viewport postcss-write-svg postcss-cssnext postcss-viewport-units cssnano cssnano-preset-advanced 安装成功之后，在项目根目录下的package.json文件中，可以看到新安装的依赖包： 1234567891011121314"dependencies": &#123; "core-js": "^2.6.5", "cssnano": "^4.1.10", "cssnano-preset-advanced": "^4.0.7", "font-awesome": "^4.7.0", "postcss-aspect-ratio-mini": "^1.0.1", "postcss-cssnext": "^3.1.0", "postcss-import": "^12.0.1", "postcss-px-to-viewport": "^1.1.1", "postcss-url": "^8.0.0", "postcss-viewport-units": "^0.1.6", "postcss-write-svg": "^3.0.1", "vue": "^2.6.10" &#125;, 在项目的根目录下创建一个.postcssrc.js 或者 postcss.config.js 文件 1234567891011121314151617181920212223242526module.exports = &#123; plugins: &#123; "postcss-import": &#123;&#125;, "postcss-url": &#123;&#125;, "postcss-aspect-ratio-mini": &#123;&#125;, "postcss-write-svg": &#123; utf8: false &#125;, "postcss-cssnext": &#123;&#125;, "postcss-px-to-viewport": &#123; viewportWidth: 750, // (Number) The width of the viewport. viewportHeight: 1334, // (Number) The height of the viewport. unitPrecision: 3, // (Number) The decimal numbers to allow the REM units to grow to. viewportUnit: "vw", // (String) Expected units. selectorBlackList: [".ignore", ".hairlines"], // (Array) The selectors to ignore and leave as px. minPixelValue: 1, // (Number) Set the minimum pixel value to replace. mediaQuery: false // (Boolean) Allow px to be converted in media queries. &#125;, "postcss-viewport-units": &#123;&#125;, cssnano: &#123; preset: "advanced", autoprefixer: false, "postcss-zindex": false &#125; &#125;&#125;; 注意：由于cssnext和cssnano都具有autoprefixer,事实上只需要一个，所以把默认的autoprefixer删除掉，然后把cssnano中的autoprefixer设置为false。修改好配置文件后yarn serve 重新跑项目，即可将px转为vw。 h5 在全屏iphonex中的适配iPhoneX 取消了物理按键，改成底部小黑条，顶部（刘海部位）。 安全区域 安全区域指的是一个可视窗口范围，处于安全区域的内容不受圆角（corners）、齐刘海（sensor housing）、小黑条（Home Indicator）影响，如下图蓝色区域： viewport-fit iOS11 新增特性，苹果公司为了适配 iPhoneX 对现有 viewport meta 标签的一个扩展，用于设置网页在可视窗口的布局方式，可设置三个值： contain: 可视窗口完全包含网页内容（左图） cover：网页内容完全覆盖可视窗口（右图） auto：默认值，跟 contain 表现一致 注意：网页默认不添加扩展的表现是 viewport-fit=contain，需要适配 iPhoneX 必须设置 viewport-fit=cover，这是适配的关键步骤。 env() 和 constant() iOS11 新增特性，Webkit 的一个 CSS 函数，用于设定安全区域与边界的距离，有四个预定义的变量： safe-area-inset-left：安全区域距离左边边界距离 safe-area-inset-right：安全区域距离右边边界距离 safe-area-inset-top：安全区域距离顶部边界距离 safe-area-inset-bottom：安全区域距离底部边界距离 constant() 在 iOS11.2 之后就不能使用的，需要做向后兼容： 1234padding-bottom: constant(safe-area-inset-bottom); /* 兼容 iOS &lt; 11.2 */padding-bottom: env(safe-area-inset-bottom); /* 兼容 iOS &gt;= 11.2 *///注意：env() 跟 constant() 需要同时存在，而且顺序不能换。 @supports 隔离兼容模式 1234567891011121314151617@mixin iphonex-css &#123; padding-top: constant(safe-area-inset-top); //为导航栏+状态栏的高度 88px padding-top: env(safe-area-inset-top); //为导航栏+状态栏的高度 88px padding-left: constant(safe-area-inset-left); //如果未竖屏时为0 padding-left: env(safe-area-inset-left); //如果未竖屏时为0 padding-right: constant(safe-area-inset-right); //如果未竖屏时为0 padding-right: env(safe-area-inset-right); //如果未竖屏时为0 padding-bottom: constant(safe-area-inset-bottom); //为底下圆弧的高度 34px padding-bottom: env(safe-area-inset-bottom); //为底下圆弧的高度 34px&#125;@mixin iphonex-support &#123; @supports (bottom: constant(safe-area-inset-top)) or (bottom: env(safe-area-inset-top)) &#123; body.iphonex &#123; @include iphonex-css; &#125; &#125;&#125; 使用@media 媒体查询123456789101112131415161718@mixin iphonex-css &#123; padding-top: constant(safe-area-inset-top); //为导航栏+状态栏的高度 88px padding-top: env(safe-area-inset-top); //为导航栏+状态栏的高度 88px padding-left: constant(safe-area-inset-left); //如果未竖屏时为0 padding-left: env(safe-area-inset-left); //如果未竖屏时为0 padding-right: constant(safe-area-inset-right); //如果未竖屏时为0 padding-right: env(safe-area-inset-right); //如果未竖屏时为0 padding-bottom: constant(safe-area-inset-bottom); //为底下圆弧的高度 34px padding-bottom: env(safe-area-inset-bottom); //为底下圆弧的高度 34px&#125;// iphonex 适配@mixin iphonex-media &#123; @media only screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) &#123; body.iphonex &#123; @include iphonex-css; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DvaJs学习]]></title>
    <url>%2F2019%2F08%2F26%2Freact-dva%2F</url>
    <content type="text"><![CDATA[Dva 学习概念：dva.js是阿里前端团队开发的一个机遇react、redux、webpack的一个前端框架，能够实现react-redux-webpack环境一键部署，能够帮助前端工程师节省搭建时间。 数据流向： 数据的改变发生通常是通过用户交互行为或者浏览器行为触发的，当此类行为会改变数据时可以通过dispatch发起一个action，如果是同步行为会通过Reducers改变State，如果是异步行为会触发Effects然后流向Reducers最终改变State。 前端代码结构： （1）page负责与用户直接打交道：渲染页面，接受用户的操作输入、侧重于展示型交互性逻辑。 （2）Model负责处理业务逻辑，为Page做数据、状态的读写、变换、暂存等。 （3）Service负责与HTTP接口对接，进行纯粹的数据读写。 Models State State表示Model的状态数据，通常表现为一个JS对象，操作的时候每次都要当做不可变数据来对待，保证每次都是全新的对象，没有引用关系，这样才能保证State的独立性，便于测试和追踪变化。 Action Action是一个普通的JS对象，它是改变State的唯一途径，无论是从UI事件、网络回调，还是WebSocket等数据所获得的数据，最终会通过dispatch函数调用一个action，从而改变对应的数据，action必须带有type属性指明具体的行为，其他字段可以自定义。如果要发起一个action需要用dispatch函数，需要注意的是dispatch组件connect Models以后，通过props传入的。 dispatch函数 在dva中，connect Model的组件通过props可以访问到dispatch，可以调用Model中的Reducers或者Effects，常见的形式如： 1234dispatch(&#123; type:'user/add', // 如果是在model外调用，需要添加namespace payload:&#123;&#125;, // 需要传递的信息&#125;)； dispatch函数就是和dva model打交道的唯一途径，dispatch函数接受一个对象作为入参，在概念中称为action，唯一强制要包含的是type字段，string类型，用来告诉dva我们想要做什么。 dishpatch是一个用于触发action的函数，action是改变State的唯一途径，但他只描述了一个行为，而dispatch可以看作是触发这个行为的方式，而Reducer则是描述如何改变数据。 Reducer 1type Reducer&lt;S,A&gt; = (state:S,action:A) =&gt; S 每个reducer都是一个function，action派发后，通过action.type被唯一匹配到，随后执行函数体逻辑，返回被dva使用作为新的state，state的改变随后会被connect注入到组件中，触发视图改变。 Effect 异步操作，也称为副作用。之所以叫副作用是因为同样的输入不一定获得同样的输出。dva为了控制副作用的操作，底层引入了redux-sagas做异步流程控制，将异步转成同步写法。根据函数式编程，计算以外的操作都属于Effect，典型的就是I/O操作、数据库读写。 当action 被dispatch之后，会先到达effect处理副作用，然后最终会促使新的action发送出去，这样新的action可能被其他的effect再捕获继续处理，也可能被reducer捕获并结束，无论怎样，最终处理逻辑的终点都是reducer。 dva中一个典型的effect的写法是： 1234getData:function* (&#123;payload&#125;,&#123;call,put&#125;)&#123; const data = yield call(SomeService.getEndpointData,payload,'maybeSomeOtherParams'); yield put(&#123;type:'getData_success&#125;,payload:data&#125;);&#125; call:执行异步函数 put:发出一个Action，类似于dispatch Subscription 用于订阅数据源，然后根据条件dispatch需要的action，数据源可以是当前的时间、服务器的websocket连接，keyboard输入、geolocation变化、history路由变化等。 Router 这里的路由通常指的是前端路由，由于我们的应用现在通常是单页应用，所以需要前端代码来控制路由逻辑，通过浏览器提供History API可以监听url的变化，从而控制路由相关操作。 dva 实例提供了router方法来控制路由，使用react-router 1234567import &#123;Router，Route&#125; from "dav-router";app.router((&#123;history&#125;) =&gt; &lt;Router history = &#123;history&#125;&gt; &lt;Route path="/" component = &#123;HomePage&#125;/&gt; &lt;/Router&gt;) 一个简易的dva结构 1234567891011121314151617181920212223// 创建应用const app = dva();// 注册 Modelapp.model(&#123; namespace:'count', state:0, reducers:&#123; add(state)&#123;return state + 1&#125;, &#125;, effects:&#123; *addAfter1Second(action,&#123;call,put&#125;)&#123; yield call(delay,1000); yield put(&#123;type:'add'&#125;); &#125;, &#125;,&#125;);// 注册视图app.router(()=&gt;&lt;ConnectedApp/&gt;);// 启动应用app.start('#root');]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 添加分类模块1$ hexo new page categories 添加标签模块1$ hexo new page tags]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
</search>
