<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vuex学习]]></title>
    <url>%2F2019%2F08%2F27%2Fvuex%E5%AE%9E%E6%88%98%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[安装 123npm install vuex --save//或yarn add vuex 使用步骤 创建store文件夹 1234567891011121314151617181920//store/store.jsimport Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export const store = new Vuex.Store(&#123; state: &#123; products: [ &#123; name: "马云", price: 200 &#125;, &#123; name: "马化腾", price: 100 &#125;, &#123; name: "马冬梅", price: 20 &#125;, &#123; name: "马蓉", price: 10 &#125; ] &#125;&#125;);//注意new Vuex.Store的Store的S是大写，否则报错为Uncaught TypeError: vuex__WEBPACK_IMPORTED_MODULE_1__.default.store is not a constructor 在main.js中引入store 1234567import &#123;store&#125; from './store/store';new Vue(&#123; store, el:"#app", render:h =&gt; h(App)&#125;) 使用数据 123456789//在组件中//product-list-one.vue中利用computed属性获取store中的数据export default &#123; computed:&#123; products()&#123; return this.$store.state.products; &#125; &#125;&#125; 在完成数据初步渲染之后在组件一种实现改变商品价格的操作首先获取需要改变的数据，然后在计算属性中对数据进行改变 1234567891011121314151617computed: &#123; products() &#123; return this.$store.state.products; &#125;, saleProducts() &#123; let saleProducts = this.$store.state.products.map(product =&gt; &#123; return &#123; name: "**" + product.name + "**", price: product.price / 2 &#125;; &#125;); return saleProducts; &#125; &#125; //将遍历对象改为saleProducts &lt;li v-for="(item,index) in saleProducts" :key="index"&gt;&lt;/li&gt; 但对于多个组价共用次方法则多次复制比较麻烦，需改为以下方式将方法抽离到store.js中的getters 在store.js中 1234567891011getters:&#123; saleProducts:(state) =&gt; &#123; let saleProducts = state.products.map(product =&gt; &#123; return &#123; name: "**" + product.name + "**", price: product.price / 2 &#125;; &#125;); return saleProducts; &#125; &#125; 实现商品降价功能 在vue中只需在methods中添加一个方法 1234567methods:&#123; reducePrice()&#123; this.$store.state.products.forEach(product =&gt; &#123; product.price -= 1; &#125;) &#125;&#125; 更改Vuex的store中的状态的唯一方法是提交mutation,Vuex中的mutation非常类似于事件，没个mutation都有一个字符串的事件类型[type]和一个回调函数，这个回调函数就是我们实际运行状态更改的地方，并且他会接受state作为第一个参数。 一般在触发事件时才使用mutation，如果是想要获取数据时就使用getters,想要存储数据时就用state， 12345678910111213141516//store.js//触发事件，改变数据 mutations: &#123; reducePrice: state =&gt; &#123; state.products.forEach(product =&gt; &#123; product.price -= 1; &#125;); &#125; &#125;//在组件中使用时用commit激活事件，事件触发的事件名字要与store中的事件名字相同methods: &#123; reducePrice() &#123; this.$store.commit("reducePrice"); &#125; &#125; vueX还兼容严格模式。 ActionsActions提交的是mutation，而不是直接变更的数据状态。 如果实现异步操作应该在Action中实现。 Action是通过store.dispatch触发的。 1234567891011121314151617//store/store.jsactions: &#123; reducePrice: context =&gt; &#123; setTimeout(() =&gt; &#123; context.commit("reducePrice"); &#125;, 2000); &#125; &#125;//组件中 methods: &#123; reducePrice() &#123; // this.$store.commit("reducePrice"); //此处commit是直接触发mutation中的方法 // 此处应调用actions里的方法 this.$store.dispatch("reducePrice"); //事件名对应store中actions中的方法名 &#125; &#125; Actions 可以进行传参 组件方法中将参数写到分发事件后进行传递，store中通过payload参数进行接收。 123456789101112131415161718192021222324//store.js//触发事件，改变数据 mutations: &#123; reducePrice: (state,payload) =&gt; &#123; state.products.forEach(product =&gt; &#123; product.price -= payload; &#125;); &#125; &#125;, actions: &#123; reducePrice: (context, payload) =&gt; &#123; setTimeout(() =&gt; &#123; context.commit("reducePrice",payload); &#125;, 2000); &#125; &#125;//组件中 methods: &#123; reducePrice(amount) &#123; // this.$store.commit("reducePrice"); //此处commit是直接触发mutation中的方法 // 此处应调用actions里的方法 this.$store.dispatch("reducePrice",amount); //事件名对应store中actions中的方法名 &#125; &#125; 辅助函数 mapGettersmapGetters辅助函数仅仅是将store中的getters映射到局部计算属性； mapActionsmapActions辅助函数将组件的methods映射为store.dispatch调用，需要先在根节点注入store， 1234567891011121314151617181920212223242526&lt;script&gt;import &#123;mapGetters&#125; from 'vuex'import &#123;mapActions&#125; from 'vuex'export default &#123; computed:&#123; products()&#123; return this.$store.state.products; &#125;, ...mapGetters([ "saleProducts" ]) &#125;, methods:&#123; ...mapActions([ "reducePrice" ]) &#125;&#125;&lt;/script&gt;//如果你想将一个 getter 属性另取一个名字，使用对象形式：mapGetters(&#123; doneCount:"doneTodosCount"S&#125;)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue学习（五）]]></title>
    <url>%2F2019%2F08%2F27%2Fvue%E4%B8%AD%E4%BD%BF%E7%94%A8less%2F</url>
    <content type="text"><![CDATA[vue中使用less 安装less安装包 npm install less less-loader -D 在build文件夹下的webpack.base.conf.js的rules里面添加配置123456modules:&#123; rules:&#123; test:/\.less$/, loader:"style-loader！css-loader!less-loader", &#125;&#125; 最后在代码中的style标签中加上lang=”less”属性即可或者是 1&lt;style type="text/less" lang="less" rel="stylesheet/less" scoped&gt; vue中使用sass 安装sass安装包 12345npm install sass-loader -D//sass-loader依赖于node-sassnpm install -D node-sass 在build文件夹下的webpack.base.conf.js的rules里面添加配置 123456modules:&#123; rules:&#123; test:/\.sass$/, loaders:['style','css','sass'] &#125;&#125; 最后在代码中的style标签中加上lang=”scss”属性即可或者是 1&lt;style type="text/scss" lang="scss" rel="stylesheet/scss" scoped&gt; 路由——vue-router实际开发中App.vue只是作为一个存放组件的容器，其中是用来渲染通过路由映射过来的组件，当路劲更改时，中的内容会发生改变， 用映射路由。 vue-routerVue.js 路由允许我们通过不同的 URL 访问不同的内容。 通过 Vue.js 可以实现多视图的单页Web应用（single page web application，SPA）。 Vue.js 路由需要载入 vue-router 库.安装1、直接下载 / CDNhttps://unpkg.com/vue-router/dist/vue-router.js2、NPM推荐使用淘宝镜像： 1cnpm install vue-router router-link 是一个组件，该组件用于设置一个导航链接，切换不同 HTML 内容。 to 属性为目标地址， 即要显示的内容。当被点击后，内部会立刻把 to 的值传到 router.push()，所以这个值可以是一个字符串或者是描述目标位置的对象。 12345678910111213141516171819&lt;!-- 字符串 --&gt;&lt;router-link to="home"&gt;Home&lt;/router-link&gt;&lt;!-- 渲染结果 --&gt;&lt;a href="home"&gt;Home&lt;/a&gt;&lt;!-- 使用 v-bind 的 JS 表达式 --&gt;&lt;router-link v-bind:to="'home'"&gt;Home&lt;/router-link&gt;&lt;!-- 不写 v-bind 也可以，就像绑定别的属性一样 --&gt;&lt;router-link :to="'home'"&gt;Home&lt;/router-link&gt;&lt;!-- 对象形式 --&gt;&lt;router-link :to="&#123; path: 'home' &#125;"&gt;Home&lt;/router-link&gt;&lt;!-- 命名的路由 --&gt;&lt;router-link :to="&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;"&gt;User&lt;/router-link&gt;&lt;!-- 带查询参数，下面的结果为 /register?plan=private --&gt;&lt;router-link :to="&#123; path: 'register', query: &#123; plan: 'private' &#125;&#125;"&gt;Register&lt;/router-link&gt; 12345678910111213141516&lt;script src="https://unpkg.com/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script src="https://unpkg.com/vue-router/dist/vue-router.js"&gt;&lt;/script&gt; &lt;div id="app"&gt; &lt;h1&gt;Hello App!&lt;/h1&gt; &lt;p&gt; &lt;!-- 使用 router-link 组件来导航. --&gt; &lt;!-- 通过传入 `to` 属性指定链接. --&gt; &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt; &lt;router-link to="/foo"&gt;Go to Foo&lt;/router-link&gt; &lt;router-link to="/bar"&gt;Go to Bar&lt;/router-link&gt; &lt;/p&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; vue-router使用步骤： 1234567891011121314151617181920212223242526// 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)// 1. 定义 (路由) 组件。// 可以从其他文件 import 进来const Foo = &#123; template: '&lt;div&gt;foo&lt;/div&gt;' &#125;const Bar = &#123; template: '&lt;div&gt;bar&lt;/div&gt;' &#125;// 2. 定义路由// 每个路由应该映射一个组件。 其中"component" 可以是// 通过 Vue.extend() 创建的组件构造器, 或者，只是一个组件配置对象。const routes = [ &#123; path: '/foo', component: Foo &#125;, &#123; path: '/bar', component: Bar &#125;]// 3. 创建 router 实例，然后传 `routes` 配置// 你还可以传别的配置参数const router = new VueRouter(&#123; routes // (缩写) 相当于 routes: routes&#125;)// 4. 创建和挂载根实例。// 记得要通过 router 配置参数注入路由， 从而让整个应用都有路由功能const app = new Vue(&#123; router&#125;).$mount('#app') 动态路由匹配我们经常需要将具有给定模式的路线映射到同一个组件。例如，我们可能有一个User应该为所有用户呈现但具有不同用户ID的组件。在vue-router我们可以在路径中使用动态段以实现： 12345678910const User = &#123; template: '&lt;div&gt;User&lt;/div&gt;'&#125;const router = new VueRouter(&#123; routes: [ // dynamic segments start with a colon &#123; path: '/user/:id', component: User &#125; ]&#125;) 这样，网址/user/foo和/user/bar将映射到相同的路由。动态段由冒号表示:。匹配路径时，动态段的值将this.$route.params在每个组件中公开。因此，我们可以通过更新User模板来呈现当前用户ID ： 123const User = &#123; template: '&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;'&#125; 通过注入路由器，我们可以访问它this.$router以及this.$route任何组件内部的当前路由： 123456789101112131415export default &#123; computed: &#123; username () &#123; // We will see what `params` is shortly return this.$route.params.username &#125; &#125;, methods: &#123; goBack () &#123; window.history.length &gt; 1 ? this.$router.go(-1) : this.$router.push('/') &#125; &#125;&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue学习（四）]]></title>
    <url>%2F2019%2F08%2F27%2Fvue%E4%B8%AD%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%2F</url>
    <content type="text"><![CDATA[vue中路由传参 使用router-link进行路由导航，传递参数 父组件中使用标签进行导航 12//child是子页面路由路径，123是需要传递的参数&lt;router-link to="/child/123"&gt;click&lt;/router-link&gt; 子组件中使用this.$route.params.num来接收路由参数 12345678910111213141516171819&lt;template&gt; &lt;div class="child"&gt; &#123;&#123;num&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default&#123; name:'child', data()&#123; return&#123; num:0, &#125; &#125;, mounted()&#123; this.num = this.$route.params.num &#125; &#125;&lt;/script&gt; 路由配置文件router/index.js 12345&#123; path:'/child/:num', // num用来为参数占位 name:'child', component:child&#125; 地址：localhost:8080/#/child/123 直接调用$router.push 实现携带参数的跳转 父组件 1234567891011121314151617181920212223&lt;template&gt; &lt;ul&gt; &lt;li v-for="itemId in 3" :key="itemId" @click="toChild(itemId)"&gt;&#123;&#123;itemId&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;// 模板渲染中调用函数，传递参数&lt;script&gt; export default&#123; name:'home', data()&#123; return&#123; num:0, &#125; &#125;, methods:&#123; toChild(id)&#123; this.$router.push(&#123; path:`/child/$&#123;id&#125;` &#125;) &#125; &#125; &#125;&lt;/script&gt; 子组件中： 12345&lt;template&gt; &lt;div class="child"&gt; &#123;&#123;this.$route.params.id&#125;&#125; &lt;/div&gt;&lt;/template&gt; 路由配置文件中： 12345&#123; path:'/child/:id', //id用来为参数占位 name:'child', component:Child&#125; 地址：localhost:8080/#/child/1 通过路由属性中的name来确定匹配的路由，通过params来传递参数 父组件： 123456789101112131415161718192021222324&lt;template&gt; &lt;button @click="toClick"&gt;click&lt;/button&gt;&lt;/template&gt;&lt;script&gt; export default&#123; name:'home', data()&#123; return&#123; num:0, &#125; &#125;, methods:&#123; toChild()&#123; this.$router.push(&#123; //使用name来匹配路由 name:'childView', params:&#123; id:1 &#125; &#125;) &#125; &#125; &#125;&lt;/script&gt; 子组件中： 12345&lt;template&gt; &lt;div class="child"&gt; &#123;&#123;this.$route.params.id&#125;&#125; &lt;/div&gt;&lt;/template&gt; 路由配置问件中： 12345&#123; path:'/child', name:'childView', cmponent:Child,&#125; 地址：localhost:8080/#/child 使用path来匹配路由，然后通过query来传递参数，这种情况下 query传递的参数会显示在url后面?id=？ 父组件中： 123456789101112131415161718192021222324 &lt;template&gt; &lt;button @click="toClick"&gt;click&lt;/button&gt;&lt;/template&gt;&lt;script&gt; export default&#123; name:'home', data()&#123; return&#123; num:0, &#125; &#125;, methods:&#123; toChild()&#123; this.$router.push(&#123; //使用name来匹配路由 path:"/child", query:&#123; id:1 &#125; &#125;) &#125; &#125; &#125;&lt;/script&gt; 子组件中： 12345 &lt;template&gt; &lt;div class="child"&gt; &#123;&#123;this.$route.params.id&#125;&#125; &lt;/div&gt;&lt;/template&gt; 路由配置文件中： 12345&#123; path:'/child', name:'child', component:Child,&#125; 地址：localhost:8080/#/child?id=1 总结： this.$router.push进行编程式路由跳转 router-link 进行页面按钮式路由跳转 this.$route.params获取路由传递参数 this.$route.query获取路由传递参数 params 和 query 都是传递参数的，params不会在url上面出现，并且params参数是路由的一部分，是一定要存在的 query则是我们通常看到的url后面的跟在？后面的显示参数]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue学习（三）]]></title>
    <url>%2F2019%2F08%2F27%2Fvue%E4%B8%AD%E4%BD%BF%E7%94%A8mock%2F</url>
    <content type="text"><![CDATA[vue中使用mockMock.js 是一个模拟数据生成器，利用它，可以拦截ajax请求，直接模拟返回数据，这样前后端只要约定好数据格式，前端就不需要依赖后端的接口，可以直接使用模拟的数据了。这里介绍在Vue工程中使用Mockjs。在用mock进行假数据模拟时，不同模块可能会用到相同模块的mock，为了对mock同样较好的工程化管理，公用的mock会写在index里，而各自模块会单独创建文件。 安装 1npm install --save-dev mockjs index.js内容 123456789101112131415import Mock from "mockjs";import &#123; createMock &#125; from "./utils";import User from "./modules/user";// 设置所有ajax请求的超时时间，模拟网络传输耗时Mock.setup(&#123; timeout: 2000&#125;);createMock(Mock, User);export default Mock; utils.js文件 12345678910111213141516/** * createMock 创建mock方法 * @param Mock Mock对象 * @param module 当前module */const createMock = (Mock, module) =&gt; &#123; if (module.length &gt; 0) &#123; module.map((item) =&gt; &#123; Mock.mock(item.rurl, item.rtype.toLowerCase(), item.template || item.callback) &#125;) &#125;&#125;export &#123; createMock&#125; 拦截ajax请求，配置mock的数据 拦截ajax请求主要可以使用Mock中的两个方法： 1. Mock.mock( rurl, rtype, template ) 2. Mock.mock( rurl, rtype, function( options ) ) rurl：表示需要拦截的 URL，可以是 URL 字符串或 URL 正则。例如： 12/\/domain\/list\.json/'/domian/list.json' rtype：表示需要拦截的 Ajax 请求类型。例如 GET、POST等。 template：表示数据模板，可以是对象(obj)或字符串(string)。如果需要要把数据写死，可以直接写一个普通的对象。如果要让Mock随机生成，可以根据Mock模板的规则自定义。例如： 123&#123; ‘data|1-10’:[&#123;&#125;] &#125; 表示生成生成包含 1到10个空对象的数据‘@EMAIL’ 表示随机生成一个email地址‘@CNAME’ 表示随机生成一个中文人名 Stylus基本使用CSS 预处理，顾名思义，预先处理 CSS。那 stylus 咋预先处理呢？stylus 给 CSS 添加了可编程的特性，也就是说，在 stylus 中可以使用变量、函数、判断、循环一系列 CSS 没有的东西来编写样式文件，执行这一套操作之后，这个文件可编译成 CSS 文件。 安装1npm install stylus 安装之后，运行 stylus -h 可查看帮助。 运行 stylus example.styl 可将 demo.styl 文件编译成 example.css 文件。 基本使用 stylus代码： 123456789101112131415$background-color = lightblueadd (a, b = a) a = unit(a, px) b = unit(b, px) a + b.list-item.text-box span background-color: $background-color margin: add(10) padding: add(10, 5) &amp;:hover background-color: powderblue 编译后生成的 CSS 代码： 12345678910.list-item span,.text-box span &#123; background-color: #add8e6; margin: 20px; padding: 15px&#125;.list-item:hover,.text-box:hover &#123; background-color: #b0e0e6;&#125; 变量 $background-color = lightblue 上面的代码声明了变量 $background-color,并为其赋值 lightblue。 声明之后，就可以使用这个变量了： 12span background-color: $background-color 翻译成 CSS 就是： 123span&#123; background-color: lightblue;&#125; 函数 1234add (a, b = a) a = unit(a, px) b = unit(b, px) a + b 代码声明了函数 add, add 接受两个参数 a 和 b，其中 b 的默认值是 a。 add 中调用了 stylus 的内置函数 unit，此处，unit 函数为 a 和 b赋予了单位 px。最后将 a 和 b 相加，并返回结果，是的，你没有看错，没有 return，但是返回了结果。 函数调用： 123span margin: add(10) padding: add(10, 5) 翻译成 CSS 就是： 1234span &#123; margin: 20px; padding: 15px;&#125; 选择器 12345678.list-item.text-box span background-color: $background-color margin: add(10) padding: add(10, 5) &amp;:hover background-color: powderblue 先说符号，这里提到的花括号和分号在stylus中是可以省略的，不仅如此，冒号也是可以省略的，color: powderblue 你可以写成 color powderblue,没有问题。 再说缩进，先提出两个有缩进关系的选择器，上面代码片段第二行的 .text-box 和第三行的 span，其实很容易理解，这哥俩写到 CSS 里面是这样的： .text-box span{ ... } 即 span 是 .text-box 的子选择器，stylus 中以缩进表示这种关系，更加清晰明了，好看。 &amp;是父级的引用。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue学习（二）]]></title>
    <url>%2F2019%2F08%2F27%2Fvue%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[父子组件传值 父组件向子组件传值 父向子传递数据通过props 父组件代码: 1234567891011121314151617&lt;template&gt; &lt;header-box :title-txt="showTitleTxt"&gt;&lt;/header-box&gt;&lt;/template&gt;&lt;script&gt; import Header from './header' export default &#123; name: 'index', components: &#123; 'header-box': Header &#125;, data () &#123; return &#123; showTitleTxt: '首页' &#125; &#125; &#125;&lt;/script&gt; 子组件代码: 123456789101112131415161718&lt;template&gt; &lt;header&gt; &#123;&#123;thisTitleTxt&#125;&#125; &lt;/header&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: 'header-box', props: &#123; titleTxt: String &#125;, data () &#123; return &#123; thisTitleTxt: this.titleTxt &#125; &#125; &#125;&lt;/script&gt; 子组件向父组件传值 子组件向父组件传递分为两种类型。 1、子组件改变父组件传递的props（你会发现通过props中的Object类型参数传输数据，可以通过子组件改变数据内容。这种方式是可行的，但是不推荐使用，因为官方定义prop是单向绑定） 2、通过$on和$emit 通过props实现传递 父组件代码 12345678910111213141516171819&lt;template&gt; &lt;header-box :title-txt="showTitleTxt"&gt;&lt;/header-box&gt;&lt;/template&gt;&lt;script&gt; import Header from './header' export default &#123; name: 'index', components: &#123; 'header-box': Header &#125;, data () &#123; return &#123; showTitleTxt: &#123; name: '首页' &#125; &#125; &#125; &#125;&lt;/script&gt; 子组件代码: 1234567891011121314151617181920212223&lt;template&gt; &lt;header @click="changeTitleTxt"&gt; &#123;&#123;thisTitleTxt.name&#125;&#125; &lt;/header&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: 'header-box', props: &#123; titleTxt: Object &#125;, data () &#123; return &#123; thisTitleTxt: this.titleTxt.name &#125; &#125;, metheds: &#123; changeTitleTxt () &#123; this.titleTxt.name = '切换' &#125; &#125; &#125;&lt;/script&gt; 通过$on,$emit 父组件代码 12345678910111213141516171819202122232425&lt;template&gt; &lt;div id="counter-event-example"&gt; &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;button-counter v-on:increment="incrementTotal"&gt;&lt;/button-counter&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; import ButtonCounter from './buttonCounter' export default &#123; name: 'index', components: &#123; 'button-conuter': ButtonCounter &#125;, data () &#123; return &#123; total: 0 &#125; &#125;, methods: &#123; incrementTotal () &#123; this.total++ &#125; &#125; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue学习（一）]]></title>
    <url>%2F2019%2F08%2F27%2Fvue%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[安装12345678910// 安装最新版本npm install -g @vue/cli# ORyarn global add @vue/cli// 查看版本号vue --version# ORvue -V// + @vue/cli@3.10.0 创建新项目 2.9.6 版本 12345678910// 创建新项目vue init webpack vue-projectcd vue-project// 安装依赖npm install// 启动项目npm run dev 3.10.0 版本 123456// 创建新项目 vue create hello-world // 启动项目 $ cd hello-world $ yarn serve 2.9.6 版本 3.10.0 版本 使用图形化界面 通过 vue ui 命令以图形化界面创建和管理项目： 1vue ui 基础知识 v-if 和 v-show 的区别 相同点：v-if与v-show都可以动态控制dom元素显示隐藏 不同点：v-if显示隐藏是将dom元素整个添加或删除会触发回流和重绘，而v-show隐藏则是为该元素添加css–display:none，dom元素还在。 如果有频繁的切换，会首选v-show,减少对dom的频繁操作。 v-for 指令 v-for 指令需要以item in list 形式的特殊语法，list是源数据组并且item数组元素迭代的别名。 v-for 可以绑定数据到数组渲染一个列表： 1234567891011121314151617181920&lt;div id="app"&gt; &lt;ol&gt; &lt;li v-for="site in sites"&gt; &#123;&#123; site.name &#125;&#125; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; &lt;script&gt;new Vue(&#123; el: '#app', data: &#123; sites: [ &#123; name: 'Runoob' &#125;, &#123; name: 'Google' &#125;, &#123; name: 'Taobao' &#125; ] &#125;&#125;)&lt;/script&gt; 注意使用v-for时都必须会加上一个必要的key值，可以使用index作为key,但这样不太好，应该给每一条数据应该唯一的标识id，使用v-for更新已渲染的元素列表时,默认用就地复用策略;列表数据修改的时候,他会根据key值去判断某个值是否修改,如果修改,则重新渲染这一项,否则复用之前的元素。 vue 生命周期 Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。 每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段：初始化、运行中、销毁。 beforeCreate: 在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。 created: 在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 beforeMount: 在挂载开始之前被调用：相关的 render 函数首次被调用,接下来开始找实例或者组件对应的模板，编译模板为虚拟dom放入到render函数中准备渲染。 mounted：el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。接下来开始render，渲染出真实dom，此时，组件已经出现在页面中，数据、真实dom都已经处理好了,事件都已经挂载好了，可以在这里操作真实dom等事情… beforeUpdate：数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。 updated：当由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。 beforeDestroy：当经过某种途径调用$destroy方法后，实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 生命周期图示:]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Vue项目中使用vw实现移动端适配]]></title>
    <url>%2F2019%2F08%2F27%2F%E5%9C%A8Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8vw%E5%AE%9E%E7%8E%B0%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[直接使用Vue官方提供的Vue-cli的构建工具来构建Vue项目。1234567891011//首先需要安装Vue-cli：npm install -g vue-cli//构建项目：vue create project//运行项目cd projectyarn serve//在浏览器执行http://localhost:8080，就可以看以默认的页面效果 安装PostCSS插件 1npm i -S postcss-import postcss-url postcss-aspect-ratio-mini postcss-px-to-viewport postcss-write-svg postcss-cssnext postcss-viewport-units cssnano cssnano-preset-advanced 安装成功之后，在项目根目录下的package.json文件中，可以看到新安装的依赖包： 1234567891011121314"dependencies": &#123; "core-js": "^2.6.5", "cssnano": "^4.1.10", "cssnano-preset-advanced": "^4.0.7", "font-awesome": "^4.7.0", "postcss-aspect-ratio-mini": "^1.0.1", "postcss-cssnext": "^3.1.0", "postcss-import": "^12.0.1", "postcss-px-to-viewport": "^1.1.1", "postcss-url": "^8.0.0", "postcss-viewport-units": "^0.1.6", "postcss-write-svg": "^3.0.1", "vue": "^2.6.10" &#125;, 在项目的根目录下创建一个.postcssrc.js 或者 postcss.config.js 文件 1234567891011121314151617181920212223242526module.exports = &#123; plugins: &#123; "postcss-import": &#123;&#125;, "postcss-url": &#123;&#125;, "postcss-aspect-ratio-mini": &#123;&#125;, "postcss-write-svg": &#123; utf8: false &#125;, "postcss-cssnext": &#123;&#125;, "postcss-px-to-viewport": &#123; viewportWidth: 750, // (Number) The width of the viewport. viewportHeight: 1334, // (Number) The height of the viewport. unitPrecision: 3, // (Number) The decimal numbers to allow the REM units to grow to. viewportUnit: "vw", // (String) Expected units. selectorBlackList: [".ignore", ".hairlines"], // (Array) The selectors to ignore and leave as px. minPixelValue: 1, // (Number) Set the minimum pixel value to replace. mediaQuery: false // (Boolean) Allow px to be converted in media queries. &#125;, "postcss-viewport-units": &#123;&#125;, cssnano: &#123; preset: "advanced", autoprefixer: false, "postcss-zindex": false &#125; &#125;&#125;; 注意：由于cssnext和cssnano都具有autoprefixer,事实上只需要一个，所以把默认的autoprefixer删除掉，然后把cssnano中的autoprefixer设置为false。修改好配置文件后yarn serve 重新跑项目，即可将px转为vw。 h5 在全屏iphonex中的适配iPhoneX 取消了物理按键，改成底部小黑条，顶部（刘海部位）。 安全区域 安全区域指的是一个可视窗口范围，处于安全区域的内容不受圆角（corners）、齐刘海（sensor housing）、小黑条（Home Indicator）影响，如下图蓝色区域： viewport-fit iOS11 新增特性，苹果公司为了适配 iPhoneX 对现有 viewport meta 标签的一个扩展，用于设置网页在可视窗口的布局方式，可设置三个值： contain: 可视窗口完全包含网页内容（左图） cover：网页内容完全覆盖可视窗口（右图） auto：默认值，跟 contain 表现一致 注意：网页默认不添加扩展的表现是 viewport-fit=contain，需要适配 iPhoneX 必须设置 viewport-fit=cover，这是适配的关键步骤。 env() 和 constant() iOS11 新增特性，Webkit 的一个 CSS 函数，用于设定安全区域与边界的距离，有四个预定义的变量： safe-area-inset-left：安全区域距离左边边界距离 safe-area-inset-right：安全区域距离右边边界距离 safe-area-inset-top：安全区域距离顶部边界距离 safe-area-inset-bottom：安全区域距离底部边界距离 constant() 在 iOS11.2 之后就不能使用的，需要做向后兼容： 1234padding-bottom: constant(safe-area-inset-bottom); /* 兼容 iOS &lt; 11.2 */padding-bottom: env(safe-area-inset-bottom); /* 兼容 iOS &gt;= 11.2 *///注意：env() 跟 constant() 需要同时存在，而且顺序不能换。 @supports 隔离兼容模式 1234567891011121314151617@mixin iphonex-css &#123; padding-top: constant(safe-area-inset-top); //为导航栏+状态栏的高度 88px padding-top: env(safe-area-inset-top); //为导航栏+状态栏的高度 88px padding-left: constant(safe-area-inset-left); //如果未竖屏时为0 padding-left: env(safe-area-inset-left); //如果未竖屏时为0 padding-right: constant(safe-area-inset-right); //如果未竖屏时为0 padding-right: env(safe-area-inset-right); //如果未竖屏时为0 padding-bottom: constant(safe-area-inset-bottom); //为底下圆弧的高度 34px padding-bottom: env(safe-area-inset-bottom); //为底下圆弧的高度 34px&#125;@mixin iphonex-support &#123; @supports (bottom: constant(safe-area-inset-top)) or (bottom: env(safe-area-inset-top)) &#123; body.iphonex &#123; @include iphonex-css; &#125; &#125;&#125; 使用@media 媒体查询123456789101112131415161718@mixin iphonex-css &#123; padding-top: constant(safe-area-inset-top); //为导航栏+状态栏的高度 88px padding-top: env(safe-area-inset-top); //为导航栏+状态栏的高度 88px padding-left: constant(safe-area-inset-left); //如果未竖屏时为0 padding-left: env(safe-area-inset-left); //如果未竖屏时为0 padding-right: constant(safe-area-inset-right); //如果未竖屏时为0 padding-right: env(safe-area-inset-right); //如果未竖屏时为0 padding-bottom: constant(safe-area-inset-bottom); //为底下圆弧的高度 34px padding-bottom: env(safe-area-inset-bottom); //为底下圆弧的高度 34px&#125;// iphonex 适配@mixin iphonex-media &#123; @media only screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) &#123; body.iphonex &#123; @include iphonex-css; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react学习（一）]]></title>
    <url>%2F2019%2F08%2F26%2Freact%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 添加分类模块1$ hexo new page categories 添加标签模块1$ hexo new page tags]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
</search>
